@*
 * RadiantPi.Lumagen - Communication client for Lumagen RadiancePro
 * Copyright (C) 2020-2021 - Steve G. Bjorg
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see <https://www.gnu.org/licenses/>.
 *@

@page "/input-labels"

@inject IRadiancePro Client

<h1>Input Labels</h1>

<ul class="nav nav-tabs" id="tab" role="tablist">
    <li class="nav-item" role="presentation">
        <a class="nav-link active" id=@($"{RadianceProMemory.MemoryAll}-tab") data-toggle="tab" href=@($"#{RadianceProMemory.MemoryAll}") role="tab">All Memories</a>
    </li>
    <li class="nav-item" role="presentation">
        <a  class="nav-link" id=@($"{RadianceProMemory.MemoryA}-tab") data-toggle="tab" href=@($"#{RadianceProMemory.MemoryA}") role="tab">Memory A</a>
    </li>
    <li class="nav-item" role="presentation">
        <a  class="nav-link" id=@($"{RadianceProMemory.MemoryB}-tab") data-toggle="tab" href=@($"#{RadianceProMemory.MemoryB}") role="tab">Memory B</a>
    </li>
    <li class="nav-item" role="presentation">
        <a  class="nav-link" id=@($"{RadianceProMemory.MemoryC}-tab") data-toggle="tab" href=@($"#{RadianceProMemory.MemoryC}") role="tab">Memory C</a>
    </li>
    <li class="nav-item" role="presentation">
        <a  class="nav-link" id=@($"{RadianceProMemory.MemoryD}-tab") data-toggle="tab" href=@($"#{RadianceProMemory.MemoryD}") role="tab">Memory D</a>
    </li>
</ul>
<div class="tab-content" id="tabContent">
    <div id=@($"{RadianceProMemory.MemoryAll}") class="tab-pane show active pt-3" role="tabpanel">
        <form>
            <fieldset disabled=@Disabled>
                @for(var input = RadianceProInput.Input1; input <= RadianceProInput.Input8; ++input) {
                    var localInput = input;
                    <div class="mb-3">
                        <Label
                            Id=@($"{localInput}")
                            Text=@($"Input {(int)localInput} Label")
                            OriginalValue=@GetOriginalLabel(RadianceProMemory.MemoryAll, localInput)
                            CurrentValue=@GetCurrentLabel(RadianceProMemory.MemoryAll, localInput)
                            OnValueChange=@(value => CurrentLabels[(RadianceProMemory.MemoryAll, localInput)] = value)
                            OnClick="@(async () => await UpdateInputAsync(RadianceProMemory.MemoryAll, localInput))"
                        />
                    </div>
                }
            </fieldset>
        </form>
    </div>
    @for(var memory = RadianceProMemory.MemoryA; memory <= RadianceProMemory.MemoryD; ++memory) {
        var localMemory = memory;
        <div id=@($"{localMemory}") class="tab-pane pt-3" role="tabpanel">
            <form>
                <fieldset disabled=@Disabled>
                    @for(var input = RadianceProInput.Input1; input <= RadianceProInput.Input8; ++input) {
                        var localInput = input;
                        <div class="mb-3">
                            <Label
                                Id=@($"{localInput}{localMemory}")
                                Text=@($"Input {(int)localInput}{localMemory.ToString().Substring(6)} Label")
                                OriginalValue=@GetOriginalLabel(localMemory, localInput)
                                CurrentValue=@GetCurrentLabel(localMemory, localInput)
                                OnValueChange=@(value => CurrentLabels[(localMemory, localInput)] = value)
                                OnClick="@(async () => await UpdateInputAsync(localMemory, localInput))"
                            />
                        </div>
                    }
                </fieldset>
            </form>
        </div>
    }
</div>

@code {

    //--- Properties ---
    protected Dictionary<(RadianceProMemory, RadianceProInput), string> OriginalLabels = new Dictionary<(RadianceProMemory, RadianceProInput), string>();
    protected Dictionary<(RadianceProMemory, RadianceProInput), string> CurrentLabels = new Dictionary<(RadianceProMemory, RadianceProInput), string>();
    protected bool Disabled { get; set; } = true;

    //--- Methods ---
    protected override async Task OnInitializedAsync() {
        await base.OnInitializedAsync();

        // read all labels from device
        for(var input = RadianceProInput.Input1; input <= RadianceProInput.Input8; ++input) {
            var allInputLabels = new HashSet<string>();
            for(var memory = RadianceProMemory.MemoryA; memory <= RadianceProMemory.MemoryD; ++memory) {
                var label = await Client.GetInputLabelAsync(memory, input);
                CurrentLabels[(memory, input)] = label;
                OriginalLabels[(memory, input)] = label;
                allInputLabels.Add(label);
            }
        }
        DetermineLabelsForAllMemories();
        Disabled = false;
    }

    protected async Task UpdateInputAsync(RadianceProMemory memory, RadianceProInput input) {
        var label = CurrentLabels[(memory, input)];
        await Client.SetInputLabelAsync(memory, input, label);
        if(memory == RadianceProMemory.MemoryAll) {
            label = await Client.GetInputLabelAsync(RadianceProMemory.MemoryA, input);
            CurrentLabels[(RadianceProMemory.MemoryAll, input)] = label;
            OriginalLabels[(RadianceProMemory.MemoryAll, input)] = label;

            // also update each individual memory
            UpdateLabel(RadianceProMemory.MemoryA, input, label);
            UpdateLabel(RadianceProMemory.MemoryB, input, label);
            UpdateLabel(RadianceProMemory.MemoryC, input, label);
            UpdateLabel(RadianceProMemory.MemoryD, input, label);
        } else {
            label = await Client.GetInputLabelAsync(memory, input);
            CurrentLabels[(memory, input)] = label;
            OriginalLabels[(memory, input)] = label;
            DetermineLabelsForAllMemories();
        }
    }

    private string GetOriginalLabel(RadianceProMemory memory, RadianceProInput input)
        => OriginalLabels.TryGetValue((memory, input), out var value)
            ? value
            : "(loading...)";

    private string GetCurrentLabel(RadianceProMemory memory, RadianceProInput input)
        => CurrentLabels.TryGetValue((memory, input), out var value)
            ? value
            : "(loading...)";

    private void DetermineLabelsForAllMemories() {
        for(var input = RadianceProInput.Input1; input <= RadianceProInput.Input8; ++input) {
            var allInputLabels = new HashSet<string>();
            for(var memory = RadianceProMemory.MemoryA; memory <= RadianceProMemory.MemoryD; ++memory) {
                allInputLabels.Add(OriginalLabels[(memory, input)]);
            }

            // check if all memories for the same input have the same label
            if(allInputLabels.Count == 1) {
                UpdateLabel(RadianceProMemory.MemoryAll, input, allInputLabels.First());
            } else {
                UpdateLabel(RadianceProMemory.MemoryAll, input, "");
            }
        }
    }

    private void UpdateLabel(RadianceProMemory memory, RadianceProInput input, string label) {
        if(
            !CurrentLabels.TryGetValue((memory, input), out var currentLabel)
            || (currentLabel == OriginalLabels[(memory, input)])
        ) {

            // update current label when value was not modified
            CurrentLabels[(memory, input)] = label;
        }
        OriginalLabels[(memory, input)] = label;
    }
}
